#!/usr/bin/env python3
"""
YAML-driven Lab Utils

Lab utilities runner with YAML-based menu configuration.
Supports CLI options, direct script execution, and interactive dialog menus.
"""

import os
import sys
import subprocess
import argparse
from pathlib import Path

try:
    import yaml
except ImportError:
    print("Error: PyYAML not installed. Install with: pip install pyyaml", file=sys.stderr)
    sys.exit(1)

# Configuration
SCRIPT_DIR = Path(__file__).parent.resolve()
MENU_CONFIG = SCRIPT_DIR / "lab-utils-menu.yml"
GLOBAL_SCRIPTS_DIR = SCRIPT_DIR / "lab-utils.d"
LOCAL_SCRIPTS_DIR = Path.home() / ".local" / "lab-utils.d"

# Dialog settings
DIALOG_BACKTITLE = "Stellars JupyterLab DS"

# Colors for terminal output
BLUE = '\033[1;34m'
CYAN = '\033[0;36m'
GRAY = '\033[0;90m'
GREEN = '\033[0;32m'
NC = '\033[0m'  # No Color


def load_menu_config() -> dict:
    """Load menu configuration from YAML file."""
    if not MENU_CONFIG.exists():
        print(f"Error: Menu configuration not found: {MENU_CONFIG}", file=sys.stderr)
        sys.exit(1)

    with open(MENU_CONFIG) as f:
        return yaml.safe_load(f)


def get_script_description(script_path: Path) -> str:
    """Extract description from script (line starting with ##)."""
    try:
        with open(script_path) as f:
            for line in f:
                if line.startswith("##"):
                    return line[2:].strip()
        return "No description available"
    except Exception:
        return "No description available"


def scan_directory_for_menu_items(scan_dir: str) -> list:
    """
    Scan a directory for executable scripts and return menu items.

    Args:
        scan_dir: Directory path (supports ~ for home expansion)

    Returns:
        List of menu item dicts with 'name' and 'command' keys
    """
    # Expand ~ to home directory
    dir_path = Path(os.path.expanduser(scan_dir))

    if not dir_path.exists() or not dir_path.is_dir():
        return []

    items = []
    for script in sorted(dir_path.glob("*.sh")):
        if script.is_file() and os.access(script, os.X_OK):
            description = get_script_description(script)
            # Use full path as command for scanned scripts
            items.append({
                "name": f"{script.stem} - {description}",
                "command": str(script),  # Full path for dynamic scripts
                "_full_path": True  # Flag to indicate this is a full path
            })

    # Also check for .yml files (conda env definitions)
    for yml_file in sorted(dir_path.glob("*.yml")):
        if yml_file.is_file():
            description = get_script_description(yml_file)
            items.append({
                "name": f"{yml_file.stem} - {description}",
                "command": str(yml_file),
                "_full_path": True
            })

    return items


def resolve_script_path(name: str, is_full_path: bool = False) -> Path:
    """
    Resolve script path by name.
    Supports both direct paths (from YAML) and name-based lookup.

    Args:
        name: Script name or path
        is_full_path: If True, treat name as absolute path
    """
    # Handle full paths (from scan_dir dynamic items)
    if is_full_path or name.startswith("/") or name.startswith("~"):
        full_path = Path(os.path.expanduser(name))
        if full_path.exists() and full_path.is_file():
            return full_path
        return None

    # If it looks like a path (contains /), try direct resolution
    if "/" in name:
        # Check global first
        global_path = GLOBAL_SCRIPTS_DIR / name
        if global_path.exists() and global_path.is_file():
            return global_path
        # Check local
        local_path = LOCAL_SCRIPTS_DIR / name
        if local_path.exists() and local_path.is_file():
            return local_path
        # Try without assuming .d structure (parent/child -> parent.d/child.sh)
        parts = name.split("/")
        if len(parts) == 2:
            parent, child = parts
            global_nested = GLOBAL_SCRIPTS_DIR / f"{parent}.d" / f"{child}.sh"
            if global_nested.exists():
                return global_nested
            local_nested = LOCAL_SCRIPTS_DIR / f"{parent}.d" / f"{child}.sh"
            if local_nested.exists():
                return local_nested
    else:
        # Simple name - add .sh extension
        global_path = GLOBAL_SCRIPTS_DIR / f"{name}.sh"
        if global_path.exists():
            return global_path
        local_path = LOCAL_SCRIPTS_DIR / f"{name}.sh"
        if local_path.exists():
            return local_path

    return None


def get_all_scripts_from_dir(scripts_dir: Path, source_label: str) -> list:
    """Get all scripts from a directory including nested ones."""
    scripts = []
    if not scripts_dir.exists():
        return scripts

    # Track which .d directories we've already processed
    processed_subdirs = set()

    # First pass: find top-level scripts and their .d subdirectories
    for script in sorted(scripts_dir.glob("*.sh")):
        if script.is_file() and os.access(script, os.X_OK):
            name = script.stem
            description = get_script_description(script)
            scripts.append({
                "name": name,
                "description": description,
                "source": source_label,
                "level": "top",
                "path": script
            })

            # Check for corresponding .d subdirectory
            subdir = scripts_dir / f"{name}.d"
            if subdir.is_dir():
                processed_subdirs.add(subdir.name)
                for child_script in sorted(subdir.glob("*.sh")):
                    if child_script.is_file() and os.access(child_script, os.X_OK):
                        child_name = child_script.stem
                        child_description = get_script_description(child_script)
                        scripts.append({
                            "name": f"{name}/{child_name}",
                            "description": child_description,
                            "source": source_label,
                            "level": "child",
                            "path": child_script
                        })

    # Second pass: find orphan .d directories (no parent script)
    for subdir in sorted(scripts_dir.glob("*.d")):
        if subdir.is_dir() and subdir.name not in processed_subdirs:
            parent_name = subdir.name[:-2]  # Remove .d suffix
            # Add a virtual parent entry for the group
            scripts.append({
                "name": parent_name,
                "description": f"Scripts in {subdir.name}/",
                "source": source_label,
                "level": "top",
                "path": None  # No actual script
            })
            for child_script in sorted(subdir.glob("*.sh")):
                if child_script.is_file() and os.access(child_script, os.X_OK):
                    child_name = child_script.stem
                    child_description = get_script_description(child_script)
                    scripts.append({
                        "name": f"{parent_name}/{child_name}",
                        "description": child_description,
                        "source": source_label,
                        "level": "child",
                        "path": child_script
                    })

    return scripts


def get_all_scripts() -> tuple:
    """Get all scripts from global and local directories."""
    global_scripts = get_all_scripts_from_dir(GLOBAL_SCRIPTS_DIR, "global")
    local_scripts = get_all_scripts_from_dir(LOCAL_SCRIPTS_DIR, "local")
    return global_scripts, local_scripts


def show_help():
    """Display help message."""
    print("Usage: lab-utils [OPTIONS] [SCRIPT_NAME]")
    print("")
    print("Lab utilities runner - execute platform utilities and scripts")
    print("")
    print("Options:")
    print("  --help, -h         Show this help message")
    print("  --list, -l         List available scripts with descriptions")
    print("  --create-local     Create local scripts directory with demo script")
    print("")
    print("Arguments:")
    print("  SCRIPT_NAME        Execute the specified script directly")
    print("                     Use parent/child format for nested scripts")
    print("")
    print("When called without arguments, shows an interactive menu.")
    print("")
    print("Script locations:")
    print(f"  Global: {GLOBAL_SCRIPTS_DIR}")
    print(f"  Local:  {LOCAL_SCRIPTS_DIR}")
    print("")
    print("Examples:")
    print("  lab-utils                              # Show interactive menu")
    print("  lab-utils --list                       # List all available scripts")
    print("  lab-utils --create-local               # Scaffold local scripts")
    print("  lab-utils test-cuda                    # Run top-level script")
    print("  lab-utils git-utils/git-pull-repos    # Run nested script directly")


def list_scripts():
    """List all available scripts with descriptions."""
    global_scripts, local_scripts = get_all_scripts()

    if global_scripts:
        print(f"{CYAN}Global scripts{NC} {GRAY}({GLOBAL_SCRIPTS_DIR}){NC}")
        print("")
        for script in global_scripts:
            if script["level"] == "child":
                print(f"    {GRAY}└─{NC} {BLUE}{script['name']:<23}{NC} {script['description']}")
            else:
                print(f"  {BLUE}{script['name']:<25}{NC} {script['description']}")
        print("")

    if local_scripts:
        print(f"{CYAN}Local scripts{NC} {GRAY}({LOCAL_SCRIPTS_DIR}){NC}")
        print("")
        for script in local_scripts:
            if script["level"] == "child":
                print(f"    {GRAY}└─{NC} {BLUE}{script['name']:<23}{NC} {script['description']}")
            else:
                print(f"  {BLUE}{script['name']:<25}{NC} {script['description']}")
        print("")
    elif not LOCAL_SCRIPTS_DIR.exists():
        print(f"{GRAY}No local scripts directory. Run --create-local to create one.{NC}")
        print("")


def create_local_scripts():
    """Create local scripts directory with demo script."""
    if LOCAL_SCRIPTS_DIR.exists():
        print(f"{CYAN}Local scripts directory already exists:{NC} {LOCAL_SCRIPTS_DIR}")
        print("")
        print("Use 'lab-utils --list' to see available scripts.")
        return

    print(f"{CYAN}Creating local scripts directory...{NC}")
    LOCAL_SCRIPTS_DIR.mkdir(parents=True, exist_ok=True)

    demo_script = LOCAL_SCRIPTS_DIR / "my-script.sh"
    demo_content = '''#!/bin/bash
## My custom script - template for local utilities

# Colors for output
GREEN='\\033[0;32m'
BLUE='\\033[0;34m'
NC='\\033[0m' # No Color

echo -e "${GREEN}Hello from your local script!${NC}"
echo ""
echo -e "${BLUE}This is a template script in your local lab-utils directory.${NC}"
echo "Edit this file or create new .sh scripts in:"
echo "  ${HOME}/.local/lab-utils.d/"
echo ""
echo "Tips:"
echo "  - Add '## Description' as the second line for --list display"
echo "  - Make scripts executable: chmod +x script.sh"
echo "  - Create parent.d/ subdirectories for nested scripts"
echo ""
echo "Arguments received: $@"
'''

    demo_script.write_text(demo_content)
    demo_script.chmod(0o755)

    print(f"{GREEN}Created local scripts directory:{NC} {LOCAL_SCRIPTS_DIR}")
    print(f"{GREEN}Created demo script:{NC} {demo_script}")
    print("")
    print("Next steps:")
    print(f"  1. Edit {demo_script} for your needs")
    print(f"  2. Create additional .sh scripts in {LOCAL_SCRIPTS_DIR}")
    print("  3. Run 'lab-utils --list' to see your scripts")


def execute_script(name: str, args: list = None):
    """Execute a script by name with optional arguments."""
    script_path = resolve_script_path(name)

    if script_path is None:
        print(f"Error: Script '{name}' not found")
        print("")
        print("Use 'lab-utils --list' to see available scripts")
        sys.exit(1)

    print(f"Executing: {script_path}")
    cmd = [str(script_path)] + (args or [])
    result = subprocess.run(cmd)
    sys.exit(result.returncode)


def run_dialog_menu(title: str, items: list, is_submenu: bool = False) -> str:
    """Display a dialog menu and return the selected item tag."""
    menu_items = []

    # Always show navigation option - Back in submenus, Exit at top level
    if is_submenu:
        menu_items.extend(["BACK", "<- Back"])
    else:
        menu_items.extend(["EXIT", "<- Exit"])

    for i, item in enumerate(items, 1):
        tag = str(i)
        name = item.get("name", f"Item {i}")
        if "submenu" in item or "scan_dir" in item:
            name = f"{name} ->"
        menu_items.extend([tag, name])

    menu_height = min(len(items) + 1, 15)  # +1 for Back/Exit option

    try:
        result = subprocess.run(
            [
                "dialog",
                "--backtitle", DIALOG_BACKTITLE,
                "--title", title,
                "--menu", "Select an option:",
                "20", "70", str(menu_height)
            ] + menu_items,
            stderr=subprocess.PIPE,
            text=True
        )

        if result.returncode == 0:
            return result.stderr.strip()
        return None

    except FileNotFoundError:
        print("Error: dialog utility not found", file=sys.stderr)
        sys.exit(1)


def execute_menu_command(command: str, title: str, is_full_path: bool = False):
    """Execute a script from menu selection."""
    script_path = resolve_script_path(command, is_full_path)

    if script_path is None:
        subprocess.run([
            "dialog",
            "--backtitle", DIALOG_BACKTITLE,
            "--title", "Error",
            "--msgbox", f"Script not found: {command}",
            "8", "50"
        ])
        return

    subprocess.run(["clear"])
    print(f"\n=== {title} ===\n")

    try:
        result = subprocess.run([str(script_path)])
        exit_code = result.returncode
    except Exception as e:
        print(f"\nError executing script: {e}")
        exit_code = 1

    print(f"\n{'=' * 40}")
    if exit_code == 0:
        print("Script completed successfully.")
    else:
        print(f"Script exited with code: {exit_code}")

    input("\nPress Enter to continue...")


def build_menu_items(menu_config: dict) -> list:
    """
    Build menu items list, combining static items with dynamic scan_dir items.

    Processes each item in the menu config:
    - Items with only 'submenu' use static items
    - Items with only 'scan_dir' get items from directory scan
    - Items with both 'submenu' and 'scan_dir' combine static + dynamic items
    """
    items = list(menu_config.get("items", []))

    # Process top-level scan_dir if present (for menus that are purely dynamic)
    if "scan_dir" in menu_config and "items" not in menu_config:
        return scan_directory_for_menu_items(menu_config["scan_dir"])

    return items


def navigate_menu(menu_config: dict, breadcrumb: list = None):
    """Navigate through menus recursively."""
    if breadcrumb is None:
        breadcrumb = []

    title = menu_config.get("title", "Menu")
    items = build_menu_items(menu_config)
    is_submenu = bool(breadcrumb)

    if breadcrumb:
        display_title = " > ".join(breadcrumb + [title])
    else:
        display_title = title

    while True:
        selection = run_dialog_menu(display_title, items, is_submenu=is_submenu)

        if selection is None:
            return

        if selection in ("BACK", "EXIT"):
            return

        try:
            index = int(selection) - 1
            selected_item = items[index]
        except (ValueError, IndexError):
            continue

        item_name = selected_item.get("name", "")

        # Handle items with submenu and/or scan_dir
        if "submenu" in selected_item or "scan_dir" in selected_item:
            # Build submenu items: static submenu + dynamic scan_dir
            submenu_items = list(selected_item.get("submenu", []))
            if "scan_dir" in selected_item:
                dynamic_items = scan_directory_for_menu_items(selected_item["scan_dir"])
                submenu_items.extend(dynamic_items)

            if submenu_items:
                submenu_config = {
                    "title": item_name,
                    "items": submenu_items
                }
                navigate_menu(submenu_config, breadcrumb + [title])
            else:
                # Empty submenu - show message
                subprocess.run([
                    "dialog",
                    "--backtitle", DIALOG_BACKTITLE,
                    "--title", "Info",
                    "--msgbox", f"No items found in {item_name}",
                    "8", "50"
                ])

        elif "command" in selected_item:
            is_full_path = selected_item.get("_full_path", False)
            execute_menu_command(selected_item["command"], item_name, is_full_path)


def run_interactive_menu():
    """Run the interactive YAML-driven menu."""
    # Check if dialog is available
    if subprocess.run(["which", "dialog"], capture_output=True).returncode != 0:
        print("Error: dialog command not found. Install it with:")
        print("  Ubuntu/Debian: sudo apt install dialog")
        print("  CentOS/RHEL: sudo yum install dialog")
        sys.exit(1)

    config = load_menu_config()
    menu = config.get("menu", {})

    navigate_menu(menu)

    subprocess.run(["clear"])
    print("Lab Utils closed.")


def main():
    """Main entry point."""
    # Parse arguments manually for flexibility
    args = sys.argv[1:]

    if not args:
        run_interactive_menu()
        return

    if args[0] in ("--help", "-h"):
        show_help()
    elif args[0] in ("--list", "-l"):
        list_scripts()
    elif args[0] == "--create-local":
        create_local_scripts()
    elif args[0].startswith("-"):
        print(f"Unknown option: {args[0]}")
        print("Use --help for usage information")
        sys.exit(1)
    else:
        # Execute script directly
        execute_script(args[0], args[1:])


if __name__ == "__main__":
    main()
