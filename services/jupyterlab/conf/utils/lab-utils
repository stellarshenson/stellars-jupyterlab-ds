#!/usr/bin/env python3
"""
YAML-driven Lab Utils

Lab utilities runner with YAML-based menu configuration.
Supports CLI options, direct script execution, and interactive Textual TUI.
"""

import os
import sys
import subprocess
from pathlib import Path

try:
    import yaml
except ImportError:
    print("Error: PyYAML not installed. Install with: pip install pyyaml", file=sys.stderr)
    sys.exit(1)

# Configuration
SCRIPT_DIR = Path(__file__).parent.resolve()
MENU_CONFIG = SCRIPT_DIR / "lab-utils-menu.yml"
GLOBAL_SCRIPTS_DIR = SCRIPT_DIR / "lab-utils.d"
LOCAL_SCRIPTS_DIR = Path.home() / ".local" / "lab-utils.d"

# Colors for terminal output (CLI mode)
BLUE = '\033[1;34m'
CYAN = '\033[0;36m'
GRAY = '\033[0;90m'
GREEN = '\033[0;32m'
NC = '\033[0m'  # No Color


def load_menu_config() -> dict:
    """Load menu configuration from YAML file."""
    if not MENU_CONFIG.exists():
        print(f"Error: Menu configuration not found: {MENU_CONFIG}", file=sys.stderr)
        sys.exit(1)

    with open(MENU_CONFIG) as f:
        return yaml.safe_load(f)


def get_script_description(script_path: Path) -> str:
    """Extract description from script (line starting with ##)."""
    try:
        with open(script_path) as f:
            for line in f:
                if line.startswith("##"):
                    return line[2:].strip()
        return "No description available"
    except Exception:
        return "No description available"


def scan_directory_for_menu_items(scan_dir: str) -> list:
    """
    Scan a directory for executable scripts and return menu items.

    Args:
        scan_dir: Directory path (supports ~ for home expansion)

    Returns:
        List of menu item dicts with 'name' and 'command' keys
    """
    dir_path = Path(os.path.expanduser(scan_dir))

    if not dir_path.exists() or not dir_path.is_dir():
        return []

    items = []
    for script in sorted(dir_path.glob("*.sh")):
        if script.is_file() and os.access(script, os.X_OK):
            description = get_script_description(script)
            items.append({
                "name": f"{script.stem} - {description}",
                "command": str(script),
                "_full_path": True
            })

    for yml_file in sorted(dir_path.glob("*.yml")):
        if yml_file.is_file():
            description = get_script_description(yml_file)
            items.append({
                "name": f"{yml_file.stem} - {description}",
                "command": str(yml_file),
                "_full_path": True
            })

    return items


def resolve_script_path(name: str, is_full_path: bool = False) -> Path:
    """Resolve script path by name."""
    if is_full_path or name.startswith("/") or name.startswith("~"):
        full_path = Path(os.path.expanduser(name))
        if full_path.exists() and full_path.is_file():
            return full_path
        return None

    if "/" in name:
        global_path = GLOBAL_SCRIPTS_DIR / name
        if global_path.exists() and global_path.is_file():
            return global_path
        local_path = LOCAL_SCRIPTS_DIR / name
        if local_path.exists() and local_path.is_file():
            return local_path
        parts = name.split("/")
        if len(parts) == 2:
            parent, child = parts
            global_nested = GLOBAL_SCRIPTS_DIR / f"{parent}.d" / f"{child}.sh"
            if global_nested.exists():
                return global_nested
            local_nested = LOCAL_SCRIPTS_DIR / f"{parent}.d" / f"{child}.sh"
            if local_nested.exists():
                return local_nested
    else:
        global_path = GLOBAL_SCRIPTS_DIR / f"{name}.sh"
        if global_path.exists():
            return global_path
        local_path = LOCAL_SCRIPTS_DIR / f"{name}.sh"
        if local_path.exists():
            return local_path

    return None


def get_all_scripts_from_dir(scripts_dir: Path, source_label: str) -> list:
    """Get all scripts from a directory including nested ones."""
    scripts = []
    if not scripts_dir.exists():
        return scripts

    processed_subdirs = set()

    for script in sorted(scripts_dir.glob("*.sh")):
        if script.is_file() and os.access(script, os.X_OK):
            name = script.stem
            description = get_script_description(script)
            scripts.append({
                "name": name,
                "description": description,
                "source": source_label,
                "level": "top",
                "path": script
            })

            subdir = scripts_dir / f"{name}.d"
            if subdir.is_dir():
                processed_subdirs.add(subdir.name)
                for child_script in sorted(subdir.glob("*.sh")):
                    if child_script.is_file() and os.access(child_script, os.X_OK):
                        child_name = child_script.stem
                        child_description = get_script_description(child_script)
                        scripts.append({
                            "name": f"{name}/{child_name}",
                            "description": child_description,
                            "source": source_label,
                            "level": "child",
                            "path": child_script
                        })

    for subdir in sorted(scripts_dir.glob("*.d")):
        if subdir.is_dir() and subdir.name not in processed_subdirs:
            parent_name = subdir.name[:-2]
            scripts.append({
                "name": parent_name,
                "description": f"Scripts in {subdir.name}/",
                "source": source_label,
                "level": "top",
                "path": None
            })
            for child_script in sorted(subdir.glob("*.sh")):
                if child_script.is_file() and os.access(child_script, os.X_OK):
                    child_name = child_script.stem
                    child_description = get_script_description(child_script)
                    scripts.append({
                        "name": f"{parent_name}/{child_name}",
                        "description": child_description,
                        "source": source_label,
                        "level": "child",
                        "path": child_script
                    })

    return scripts


def get_all_scripts() -> tuple:
    """Get all scripts from global and local directories."""
    global_scripts = get_all_scripts_from_dir(GLOBAL_SCRIPTS_DIR, "global")
    local_scripts = get_all_scripts_from_dir(LOCAL_SCRIPTS_DIR, "local")
    return global_scripts, local_scripts


def show_help():
    """Display help message."""
    print("Usage: lab-utils [OPTIONS] [SCRIPT_NAME]")
    print("")
    print("Lab utilities runner - execute platform utilities and scripts")
    print("")
    print("Options:")
    print("  --help, -h         Show this help message")
    print("  --list, -l         List available scripts with descriptions")
    print("  --create-local     Create local scripts directory with demo script")
    print("")
    print("Arguments:")
    print("  SCRIPT_NAME        Execute the specified script directly")
    print("                     Use parent/child format for nested scripts")
    print("")
    print("When called without arguments, shows an interactive menu.")
    print("")
    print("Script locations:")
    print(f"  Global: {GLOBAL_SCRIPTS_DIR}")
    print(f"  Local:  {LOCAL_SCRIPTS_DIR}")
    print("")
    print("Examples:")
    print("  lab-utils                              # Show interactive menu")
    print("  lab-utils --list                       # List all available scripts")
    print("  lab-utils --create-local               # Scaffold local scripts")
    print("  lab-utils test-cuda                    # Run top-level script")
    print("  lab-utils git-utils/git-pull-repos    # Run nested script directly")


def list_scripts():
    """List all available scripts with descriptions."""
    global_scripts, local_scripts = get_all_scripts()

    if global_scripts:
        print(f"{CYAN}Global scripts{NC} {GRAY}({GLOBAL_SCRIPTS_DIR}){NC}")
        print("")
        for script in global_scripts:
            if script["level"] == "child":
                print(f"    {GRAY}└─{NC} {BLUE}{script['name']:<23}{NC} {script['description']}")
            else:
                print(f"  {BLUE}{script['name']:<25}{NC} {script['description']}")
        print("")

    if local_scripts:
        print(f"{CYAN}Local scripts{NC} {GRAY}({LOCAL_SCRIPTS_DIR}){NC}")
        print("")
        for script in local_scripts:
            if script["level"] == "child":
                print(f"    {GRAY}└─{NC} {BLUE}{script['name']:<23}{NC} {script['description']}")
            else:
                print(f"  {BLUE}{script['name']:<25}{NC} {script['description']}")
        print("")
    elif not LOCAL_SCRIPTS_DIR.exists():
        print(f"{GRAY}No local scripts directory. Run --create-local to create one.{NC}")
        print("")


def create_local_scripts():
    """Create local scripts directory with demo script."""
    if LOCAL_SCRIPTS_DIR.exists():
        print(f"{CYAN}Local scripts directory already exists:{NC} {LOCAL_SCRIPTS_DIR}")
        print("")
        print("Use 'lab-utils --list' to see available scripts.")
        return

    print(f"{CYAN}Creating local scripts directory...{NC}")
    LOCAL_SCRIPTS_DIR.mkdir(parents=True, exist_ok=True)

    demo_script = LOCAL_SCRIPTS_DIR / "my-script.sh"
    demo_content = '''#!/bin/bash
## My custom script - template for local utilities

# Colors for output
GREEN='\\033[0;32m'
BLUE='\\033[0;34m'
NC='\\033[0m' # No Color

echo -e "${GREEN}Hello from your local script!${NC}"
echo ""
echo -e "${BLUE}This is a template script in your local lab-utils directory.${NC}"
echo "Edit this file or create new .sh scripts in:"
echo "  ${HOME}/.local/lab-utils.d/"
echo ""
echo "Tips:"
echo "  - Add '## Description' as the second line for --list display"
echo "  - Make scripts executable: chmod +x script.sh"
echo "  - Create parent.d/ subdirectories for nested scripts"
echo ""
echo "Arguments received: $@"
'''

    demo_script.write_text(demo_content)
    demo_script.chmod(0o755)

    print(f"{GREEN}Created local scripts directory:{NC} {LOCAL_SCRIPTS_DIR}")
    print(f"{GREEN}Created demo script:{NC} {demo_script}")
    print("")
    print("Next steps:")
    print(f"  1. Edit {demo_script} for your needs")
    print(f"  2. Create additional .sh scripts in {LOCAL_SCRIPTS_DIR}")
    print("  3. Run 'lab-utils --list' to see your scripts")


def execute_script(name: str, args: list = None):
    """Execute a script by name with optional arguments."""
    script_path = resolve_script_path(name)

    if script_path is None:
        print(f"Error: Script '{name}' not found")
        print("")
        print("Use 'lab-utils --list' to see available scripts")
        sys.exit(1)

    print(f"Executing: {script_path}")
    cmd = [str(script_path)] + (args or [])
    result = subprocess.run(cmd)
    sys.exit(result.returncode)


# =============================================================================
# Textual TUI Menu
# =============================================================================

def run_interactive_menu():
    """Run the interactive Textual TUI menu."""
    try:
        from textual.app import App, ComposeResult
        from textual.widgets import Header, Footer, OptionList, Static
        from textual.widgets.option_list import Option, Separator
        from textual.binding import Binding
        from textual.containers import Container
    except ImportError:
        print("Error: Textual not installed. Install with: pip install textual", file=sys.stderr)
        sys.exit(1)

    config = load_menu_config()
    root_menu = config.get("menu", {})

    class LabUtilsApp(App):
        """Lab Utils TUI Application."""

        TITLE = "Lab Utils"
        SUB_TITLE = "Stellars JupyterLab DS"
        CSS = """
        Screen {
            background: $surface;
        }
        Header {
            dock: top;
            background: $primary;
            color: $text;
        }
        Footer {
            dock: bottom;
            background: $primary-darken-1;
        }
        #menu-container {
            width: 100%;
            height: 100%;
            padding: 1 2;
        }
        OptionList {
            width: 100%;
            height: 100%;
            border: round $primary;
            background: $surface;
            padding: 0 1;
        }
        OptionList:focus {
            border: round $accent;
        }
        OptionList > .option-list--option-highlighted {
            background: $accent;
            color: $text;
        }
        OptionList > .option-list--option-hover {
            background: $primary-lighten-2;
        }
        #breadcrumb {
            dock: top;
            height: 1;
            padding: 0 2;
            background: $primary-darken-2;
            color: $text-muted;
            text-style: italic;
        }
        #title-bar {
            dock: top;
            height: 3;
            padding: 1 2;
            background: $primary-darken-1;
            text-align: center;
            text-style: bold;
        }
        """

        BINDINGS = [
            Binding("q", "quit", "Quit", show=True),
            Binding("escape", "go_back", "Back", show=True),
            Binding("backspace", "go_back", "Back", show=False),
        ]

        def __init__(self):
            super().__init__()
            self.menu_stack = []  # Stack of (title, items) tuples
            self.current_items = []
            self.pending_command = None

        def compose(self) -> ComposeResult:
            yield Header()
            yield Static("", id="breadcrumb")
            with Container(id="menu-container"):
                yield OptionList(id="menu")
            yield Footer()

        def on_mount(self) -> None:
            """Initialize with root menu."""
            self.push_menu(root_menu.get("title", "Lab Utils"), root_menu.get("items", []))

        def push_menu(self, title: str, items: list) -> None:
            """Push a new menu onto the stack."""
            self.menu_stack.append((title, items))
            self.current_items = items
            self.refresh_menu()

        def pop_menu(self) -> bool:
            """Pop the current menu. Returns False if at root."""
            if len(self.menu_stack) <= 1:
                return False
            self.menu_stack.pop()
            title, items = self.menu_stack[-1]
            self.current_items = items
            self.refresh_menu()
            return True

        def get_breadcrumb(self) -> str:
            """Build breadcrumb string from menu stack."""
            if not self.menu_stack:
                return ""
            titles = [t for t, _ in self.menu_stack]
            return " > ".join(titles)

        def refresh_menu(self) -> None:
            """Refresh the menu display."""
            menu = self.query_one("#menu", OptionList)
            breadcrumb = self.query_one("#breadcrumb", Static)

            menu.clear_options()
            breadcrumb.update(self.get_breadcrumb())

            # Add navigation option
            if len(self.menu_stack) > 1:
                menu.add_option(Option("◀ Back", id="__back__"))
            else:
                menu.add_option(Option("✕ Exit", id="__exit__"))

            menu.add_option(Separator())

            # Add menu items with icons
            for i, item in enumerate(self.current_items):
                name = item.get("name", f"Item {i}")
                if "submenu" in item or "scan_dir" in item:
                    # Folder/submenu icon
                    name = f"▶ {name}"
                else:
                    # Script/command icon
                    name = f"● {name}"
                menu.add_option(Option(name, id=str(i)))

        def on_option_list_option_selected(self, event: OptionList.OptionSelected) -> None:
            """Handle menu item selection."""
            option_id = event.option.id

            if option_id == "__exit__":
                self.exit()
                return

            if option_id == "__back__":
                self.pop_menu()
                return

            try:
                index = int(option_id)
                selected_item = self.current_items[index]
            except (ValueError, IndexError):
                return

            item_name = selected_item.get("name", "")

            # Handle submenu or scan_dir
            if "submenu" in selected_item or "scan_dir" in selected_item:
                submenu_items = list(selected_item.get("submenu", []))
                if "scan_dir" in selected_item:
                    dynamic_items = scan_directory_for_menu_items(selected_item["scan_dir"])
                    submenu_items.extend(dynamic_items)

                if submenu_items:
                    self.push_menu(item_name, submenu_items)
                else:
                    self.notify(f"No items found in {item_name}", severity="warning")

            # Handle command execution
            elif "command" in selected_item:
                is_full_path = selected_item.get("_full_path", False)
                command = selected_item["command"]
                script_path = resolve_script_path(command, is_full_path)

                if script_path is None:
                    self.notify(f"Script not found: {command}", severity="error")
                    return

                # Store command and exit to execute
                self.pending_command = (str(script_path), item_name)
                self.exit()

        def action_go_back(self) -> None:
            """Handle back action."""
            if not self.pop_menu():
                self.exit()

    # Run the app
    app = LabUtilsApp()
    app.run()

    # Execute pending command after app exits
    if app.pending_command:
        script_path, title = app.pending_command
        print(f"\n{'=' * 60}")
        print(f"  {title}")
        print(f"{'=' * 60}\n")

        result = subprocess.run([script_path])

        print(f"\n{'=' * 60}")
        if result.returncode == 0:
            print("  Script completed successfully.")
        else:
            print(f"  Script exited with code: {result.returncode}")
        print(f"{'=' * 60}")

        input("\nPress Enter to continue...")

        # Re-run the menu
        run_interactive_menu()


def main():
    """Main entry point."""
    args = sys.argv[1:]

    if not args:
        run_interactive_menu()
        return

    if args[0] in ("--help", "-h"):
        show_help()
    elif args[0] in ("--list", "-l"):
        list_scripts()
    elif args[0] == "--create-local":
        create_local_scripts()
    elif args[0].startswith("-"):
        print(f"Unknown option: {args[0]}")
        print("Use --help for usage information")
        sys.exit(1)
    else:
        execute_script(args[0], args[1:])


if __name__ == "__main__":
    main()
