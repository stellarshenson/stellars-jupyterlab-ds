#!/opt/conda/bin/python3
"""
YAML-driven Lab Utils

Lab utilities runner with YAML-based menu configuration.
Supports CLI options, direct script execution, and interactive Textual TUI.
"""

import json
import os
import sys
import subprocess
from pathlib import Path

try:
    import yaml
except ImportError:
    print("Error: PyYAML not installed. Install with: pip install pyyaml", file=sys.stderr)
    sys.exit(1)

# Configuration
SCRIPT_DIR = Path(__file__).parent.resolve()
MENU_CONFIG = SCRIPT_DIR / "lab-utils.d" / "menu.yml"
GLOBAL_SCRIPTS_DIR = SCRIPT_DIR / "lab-utils.d"
LOCAL_SCRIPTS_DIR = Path.home() / ".local" / "lab-utils.d"

# Colors for terminal output (CLI mode)
BLUE = '\033[1;34m'
CYAN = '\033[0;36m'
GRAY = '\033[0;90m'
GREEN = '\033[0;32m'
NC = '\033[0m'  # No Color


def load_menu_config() -> dict:
    """Load menu configuration from YAML file."""
    if not MENU_CONFIG.exists():
        print(f"Error: Menu configuration not found: {MENU_CONFIG}", file=sys.stderr)
        sys.exit(1)

    with open(MENU_CONFIG) as f:
        return yaml.safe_load(f)


def get_script_description(script_path: Path) -> str:
    """Extract description from script (line starting with ##)."""
    try:
        with open(script_path) as f:
            for line in f:
                if line.startswith("##"):
                    return line[2:].strip()
        return "No description available"
    except Exception:
        return "No description available"


def scan_directory_for_menu_items(scan_dir: str) -> list:
    """
    Scan a directory for executable scripts and return menu items.

    Args:
        scan_dir: Directory path (supports ~ for home expansion)

    Returns:
        List of menu item dicts with 'id', 'name', 'description' keys
    """
    dir_path = Path(os.path.expanduser(scan_dir))

    if not dir_path.exists() or not dir_path.is_dir():
        return []

    items = []
    for script in sorted(dir_path.glob("*.sh")):
        if script.is_file() and os.access(script, os.X_OK):
            description = get_script_description(script)
            items.append({
                "id": str(script),  # Full path for dynamic scripts
                "name": script.stem,
                "description": description,
                "_full_path": True
            })

    for yml_file in sorted(dir_path.glob("*.yml")):
        if yml_file.is_file():
            description = get_script_description(yml_file)
            items.append({
                "id": str(yml_file),
                "name": yml_file.stem,
                "description": description,
                "_full_path": True
            })

    return items


def resolve_script_path(script_id: str, is_full_path: bool = False) -> Path:
    """
    Resolve script path from id.

    Args:
        script_id: Script path (relative to lab-utils.d/ or absolute)
        is_full_path: If True, treat script_id as absolute path

    Returns:
        Path to the script file, or None if not found
    """
    # Handle absolute paths
    if is_full_path or script_id.startswith("/") or script_id.startswith("~"):
        full_path = Path(os.path.expanduser(script_id))
        if full_path.exists() and full_path.is_file():
            return full_path
        return None

    # Check global scripts directory
    global_path = GLOBAL_SCRIPTS_DIR / script_id
    if global_path.exists() and global_path.is_file():
        return global_path

    # Check local scripts directory
    local_path = LOCAL_SCRIPTS_DIR / script_id
    if local_path.exists() and local_path.is_file():
        return local_path

    return None


def get_all_scripts_from_dir(scripts_dir: Path, source_label: str) -> list:
    """Get all scripts from a directory including nested ones."""
    scripts = []
    if not scripts_dir.exists():
        return scripts

    processed_subdirs = set()

    for script in sorted(scripts_dir.glob("*.sh")):
        if script.is_file() and os.access(script, os.X_OK):
            name = script.stem
            description = get_script_description(script)
            scripts.append({
                "name": name,
                "description": description,
                "source": source_label,
                "level": "top",
                "path": script
            })

            subdir = scripts_dir / f"{name}.d"
            if subdir.is_dir():
                processed_subdirs.add(subdir.name)
                for child_script in sorted(subdir.glob("*.sh")):
                    if child_script.is_file() and os.access(child_script, os.X_OK):
                        child_name = child_script.stem
                        child_description = get_script_description(child_script)
                        scripts.append({
                            "name": f"{name}/{child_name}",
                            "description": child_description,
                            "source": source_label,
                            "level": "child",
                            "path": child_script
                        })

    for subdir in sorted(scripts_dir.glob("*.d")):
        if subdir.is_dir() and subdir.name not in processed_subdirs:
            parent_name = subdir.name[:-2]
            scripts.append({
                "name": parent_name,
                "description": f"Scripts in {subdir.name}/",
                "source": source_label,
                "level": "top",
                "path": None
            })
            for child_script in sorted(subdir.glob("*.sh")):
                if child_script.is_file() and os.access(child_script, os.X_OK):
                    child_name = child_script.stem
                    child_description = get_script_description(child_script)
                    scripts.append({
                        "name": f"{parent_name}/{child_name}",
                        "description": child_description,
                        "source": source_label,
                        "level": "child",
                        "path": child_script
                    })

    return scripts


def get_all_scripts() -> tuple:
    """Get all scripts from global and local directories."""
    global_scripts = get_all_scripts_from_dir(GLOBAL_SCRIPTS_DIR, "global")
    local_scripts = get_all_scripts_from_dir(LOCAL_SCRIPTS_DIR, "local")
    return global_scripts, local_scripts


def show_help():
    """Display help message."""
    print("Usage: lab-utils [OPTIONS] [SCRIPT_NAME]")
    print("")
    print("Lab utilities runner - execute platform utilities and scripts")
    print("")
    print("Options:")
    print("  --help, -h         Show this help message")
    print("  --list, -l         List available scripts with descriptions")
    print("  --json             List scripts in JSON format (machine-readable)")
    print("  --create-local     Create local scripts directory with demo script")
    print("")
    print("Arguments:")
    print("  SCRIPT_NAME        Execute the specified script directly")
    print("                     Use parent/child format for nested scripts")
    print("")
    print("When called without arguments, shows an interactive menu.")
    print("")
    print("Script locations:")
    print(f"  Global: {GLOBAL_SCRIPTS_DIR}")
    print(f"  Local:  {LOCAL_SCRIPTS_DIR}")
    print("")
    print("Examples:")
    print("  lab-utils                              # Show interactive menu")
    print("  lab-utils --list                       # List all available scripts")
    print("  lab-utils --json                       # List scripts as JSON")
    print("  lab-utils --create-local               # Scaffold local scripts")
    print("  lab-utils test-cuda                    # Run top-level script")
    print("  lab-utils git-utils/git-pull-repos    # Run nested script directly")


def list_scripts():
    """List all available scripts with descriptions in tree format."""
    global_scripts, local_scripts = get_all_scripts()

    def print_tree(scripts: list, base_dir: Path, label: str):
        """Print scripts in tree format."""
        if not scripts:
            return

        print(f"{CYAN}{label}{NC} {GRAY}({base_dir}){NC}")
        print(f"{GRAY}│{NC}")

        # Process scripts with proper tree connectors
        i = 0
        while i < len(scripts):
            script = scripts[i]
            name = script["name"]

            # Find remaining top-level items after this one
            remaining_top = sum(1 for s in scripts[i+1:] if s["level"] == "top")

            if script["level"] == "top":
                # Collect children for this parent
                children = []
                j = i + 1
                while j < len(scripts) and scripts[j]["level"] == "child":
                    if scripts[j]["name"].startswith(name + "/"):
                        children.append(scripts[j])
                    j += 1

                # Determine connector for parent
                is_last_top = (remaining_top == 0 and len(children) == 0)
                connector = "└──" if is_last_top else "├──"

                if script["path"] is None:
                    # Virtual parent (folder only)
                    print(f"{GRAY}{connector}{NC} {CYAN}{name}/{NC} {GRAY}{script['description']}{NC}")
                else:
                    print(f"{GRAY}{connector}{NC} {BLUE}{name:<22}{NC} {script['description']}")

                # Print children
                for k, child in enumerate(children):
                    is_last_child = (k == len(children) - 1)
                    # Use │ prefix if more top-level items follow, else use space
                    if remaining_top > 0 or not is_last_child:
                        prefix = "│   " if remaining_top > 0 else "    "
                    else:
                        prefix = "    "
                    child_connector = "└──" if is_last_child else "├──"
                    child_name = child["name"].split("/")[-1]
                    print(f"{GRAY}{prefix}{child_connector}{NC} {BLUE}{child_name:<18}{NC} {child['description']}")

                i = j  # Skip past children we already printed
            else:
                i += 1

        print("")

    if global_scripts:
        print_tree(global_scripts, GLOBAL_SCRIPTS_DIR, "Global scripts")

    if local_scripts:
        print_tree(local_scripts, LOCAL_SCRIPTS_DIR, "Local scripts")
    elif not LOCAL_SCRIPTS_DIR.exists():
        print(f"{GRAY}No local scripts directory. Run --create-local to create one.{NC}")
        print("")


def list_scripts_json():
    """List all scripts in JSON format for machine readability."""
    global_scripts, local_scripts = get_all_scripts()

    output = {
        "global": {
            "path": str(GLOBAL_SCRIPTS_DIR),
            "scripts": []
        },
        "local": {
            "path": str(LOCAL_SCRIPTS_DIR),
            "scripts": []
        }
    }

    for script in global_scripts:
        output["global"]["scripts"].append({
            "name": script["name"],
            "description": script["description"],
            "level": script["level"],
            "path": str(script["path"]) if script["path"] else None
        })

    for script in local_scripts:
        output["local"]["scripts"].append({
            "name": script["name"],
            "description": script["description"],
            "level": script["level"],
            "path": str(script["path"]) if script["path"] else None
        })

    print(json.dumps(output, indent=2))


def create_local_scripts():
    """Create local scripts directory with demo script."""
    if LOCAL_SCRIPTS_DIR.exists():
        print(f"{CYAN}Local scripts directory already exists:{NC} {LOCAL_SCRIPTS_DIR}")
        print("")
        print("Use 'lab-utils --list' to see available scripts.")
        return

    print(f"{CYAN}Creating local scripts directory...{NC}")
    LOCAL_SCRIPTS_DIR.mkdir(parents=True, exist_ok=True)

    demo_script = LOCAL_SCRIPTS_DIR / "my-script.sh"
    demo_content = '''#!/bin/bash
## My custom script - template for local utilities

# Colors for output
GREEN='\\033[0;32m'
BLUE='\\033[0;34m'
NC='\\033[0m' # No Color

echo -e "${GREEN}Hello from your local script!${NC}"
echo ""
echo -e "${BLUE}This is a template script in your local lab-utils directory.${NC}"
echo "Edit this file or create new .sh scripts in:"
echo "  ${HOME}/.local/lab-utils.d/"
echo ""
echo "Tips:"
echo "  - Add '## Description' as the second line for --list display"
echo "  - Make scripts executable: chmod +x script.sh"
echo "  - Create parent.d/ subdirectories for nested scripts"
echo ""
echo "Arguments received: $@"
'''

    demo_script.write_text(demo_content)
    demo_script.chmod(0o755)

    print(f"{GREEN}Created local scripts directory:{NC} {LOCAL_SCRIPTS_DIR}")
    print(f"{GREEN}Created demo script:{NC} {demo_script}")
    print("")
    print("Next steps:")
    print(f"  1. Edit {demo_script} for your needs")
    print(f"  2. Create additional .sh scripts in {LOCAL_SCRIPTS_DIR}")
    print("  3. Run 'lab-utils --list' to see your scripts")


def execute_script(name: str, args: list = None):
    """Execute a script by name with optional arguments."""
    script_path = resolve_script_path(name)

    if script_path is None:
        print(f"Error: Script '{name}' not found")
        print("")
        print("Use 'lab-utils --list' to see available scripts")
        sys.exit(1)

    print(f"Executing: {script_path}")
    cmd = [str(script_path)] + (args or [])
    result = subprocess.run(cmd)
    sys.exit(result.returncode)


# =============================================================================
# Textual TUI Menu
# =============================================================================

def run_interactive_menu():
    """Run the interactive Textual TUI menu."""
    try:
        from textual.app import App, ComposeResult
        from textual.widgets import Header, Footer, OptionList, Static
        from textual.widgets.option_list import Option
        from textual.binding import Binding
        from textual.containers import Container
    except ImportError:
        print("Error: Textual not installed. Install with: pip install textual", file=sys.stderr)
        sys.exit(1)

    config = load_menu_config()
    root_menu = config.get("menu", {})

    class LabUtilsApp(App):
        """Lab Utils TUI Application."""

        TITLE = "Lab Utils"
        SUB_TITLE = "Stellars JupyterLab DS"
        CSS = """
        Screen {
            background: $surface;
        }
        Header {
            dock: top;
            background: $primary;
            color: $text;
        }
        Footer {
            dock: bottom;
            background: $primary-darken-1;
        }
        #menu-container {
            width: 100%;
            height: 100%;
            padding: 1 2;
        }
        OptionList {
            width: 100%;
            height: 100%;
            border: round $primary;
            background: $surface;
            padding: 0 1;
        }
        OptionList:focus {
            border: round $accent;
        }
        OptionList > .option-list--option-highlighted {
            background: $accent;
            color: $text;
        }
        OptionList > .option-list--option-hover {
            background: $primary-lighten-2;
        }
        #breadcrumb {
            dock: top;
            height: 1;
            padding: 0 2;
            background: $primary-darken-2;
            color: $text-muted;
            text-style: italic;
        }
        #title-bar {
            dock: top;
            height: 3;
            padding: 1 2;
            background: $primary-darken-1;
            text-align: center;
            text-style: bold;
        }
        """

        BINDINGS = [
            Binding("q", "quit", "Quit", show=True),
            Binding("escape", "go_back", "Back", show=True),
            Binding("backspace", "go_back", "Back", show=False),
        ]

        def __init__(self):
            super().__init__()
            self.menu_stack = []  # Stack of (title, items) tuples
            self.current_items = []
            self.pending_command = None

        def compose(self) -> ComposeResult:
            yield Header()
            yield Static("", id="breadcrumb")
            with Container(id="menu-container"):
                yield OptionList(id="menu")
            yield Footer()

        def on_mount(self) -> None:
            """Initialize with root menu."""
            self.push_menu(root_menu.get("title", "Lab Utils"), root_menu.get("items", []))

        def push_menu(self, title: str, items: list) -> None:
            """Push a new menu onto the stack."""
            self.menu_stack.append((title, items))
            self.current_items = items
            self.refresh_menu()

        def pop_menu(self) -> bool:
            """Pop the current menu. Returns False if at root."""
            if len(self.menu_stack) <= 1:
                return False
            self.menu_stack.pop()
            title, items = self.menu_stack[-1]
            self.current_items = items
            self.refresh_menu()
            return True

        def get_breadcrumb(self) -> str:
            """Build breadcrumb string from menu stack."""
            if not self.menu_stack:
                return ""
            titles = [t for t, _ in self.menu_stack]
            return " > ".join(titles)

        def refresh_menu(self) -> None:
            """Refresh the menu display."""
            menu = self.query_one("#menu", OptionList)
            breadcrumb = self.query_one("#breadcrumb", Static)

            menu.clear_options()
            breadcrumb.update(self.get_breadcrumb())

            # Add navigation option
            if len(self.menu_stack) > 1:
                menu.add_option(Option("◀ Back", id="__back__"))
            else:
                menu.add_option(Option("✕ Exit", id="__exit__"))

            menu.add_option(None)

            # Add menu items with icons
            for i, item in enumerate(self.current_items):
                name = item.get("name", f"Item {i}")
                desc = item.get("description", "")
                if "submenu" in item or "scan_dir" in item:
                    # Folder/submenu icon
                    display = f"▶ {name}"
                else:
                    # Script/command icon - show description if available
                    if desc:
                        display = f"● {name} - {desc}"
                    else:
                        display = f"● {name}"
                menu.add_option(Option(display, id=str(i)))

        def on_option_list_option_selected(self, event: OptionList.OptionSelected) -> None:
            """Handle menu item selection."""
            option_id = event.option.id

            if option_id == "__exit__":
                self.exit()
                return

            if option_id == "__back__":
                self.pop_menu()
                return

            try:
                index = int(option_id)
                selected_item = self.current_items[index]
            except (ValueError, IndexError):
                return

            item_name = selected_item.get("name", "")

            # Handle submenu or scan_dir
            if "submenu" in selected_item or "scan_dir" in selected_item:
                submenu_items = list(selected_item.get("submenu", []))
                if "scan_dir" in selected_item:
                    dynamic_items = scan_directory_for_menu_items(selected_item["scan_dir"])
                    submenu_items.extend(dynamic_items)

                if submenu_items:
                    self.push_menu(item_name, submenu_items)
                else:
                    self.notify(f"No items found in {item_name}", severity="warning")

            # Handle command execution (id field)
            elif "id" in selected_item:
                item_type = selected_item.get("type", "script")
                item_id = selected_item["id"]

                if item_type == "command":
                    # Direct shell command
                    self.pending_command = (item_id, item_name, "command")
                    self.exit()
                else:
                    # Script file
                    is_full_path = selected_item.get("_full_path", False)
                    script_path = resolve_script_path(item_id, is_full_path)

                    if script_path is None:
                        self.notify(f"Script not found: {item_id}", severity="error")
                        return

                    self.pending_command = (str(script_path), item_name, "script")
                    self.exit()

        def action_go_back(self) -> None:
            """Handle back action."""
            if not self.pop_menu():
                self.exit()

    # Run the app
    app = LabUtilsApp()
    app.run()

    # Execute pending command after app exits
    if app.pending_command:
        cmd_or_path, title, cmd_type = app.pending_command
        print(f"\n{'=' * 60}")
        print(f"  {title}")
        print(f"{'=' * 60}\n")

        if cmd_type == "command":
            # Shell command
            result = subprocess.run(cmd_or_path, shell=True)
        else:
            # Script file
            result = subprocess.run([cmd_or_path])

        print(f"\n{'=' * 60}")
        if result.returncode == 0:
            print("  Completed successfully.")
        else:
            print(f"  Exited with code: {result.returncode}")
        print(f"{'=' * 60}")

        input("\nPress Enter to continue...")

        # Re-run the menu
        run_interactive_menu()


def main():
    """Main entry point."""
    args = sys.argv[1:]

    if not args:
        run_interactive_menu()
        return

    if args[0] in ("--help", "-h"):
        show_help()
    elif args[0] in ("--list", "-l"):
        list_scripts()
    elif args[0] == "--json":
        list_scripts_json()
    elif args[0] == "--create-local":
        create_local_scripts()
    elif args[0].startswith("-"):
        print(f"Unknown option: {args[0]}")
        print("Use --help for usage information")
        sys.exit(1)
    else:
        execute_script(args[0], args[1:])


if __name__ == "__main__":
    main()
